# test1_1
# Тестовое задание

Необохимо отсортировать большой объем данных.
Предлагаются для реализации следующие общеизвестные алгоритмы:

  - быстрая сортировка
  - стабильная сортировка
  - сортировка кучей
  - другая(на выбор)

Задачи:

  - Сформировать большой объем данных(1 миллион элементов): чисел или строк.
  - Разработать не менее двух функций сортировки, каждая функция должна реализовывать свой алгоритм
  - Отсортировать данные (по возрастанию или по убыванию), используя стандартные операторы сравнения
  - Добиться максимально возможной производительности на многопроцессорной системе(произвести замеры)
  - Сделать выводы о преимуществах и недостатках для каждой функции

# Решение
Выбранные сортировки: сортировка кучей и сортировка выбором

Для решения задачи создадим класс (class test1). 
# Описание полей и методов класса
  - Константа enum {num_of_elements = 1000000} указывает на количество элементов, которые будут храниться в массиве data.
  - Динамически создаваемый массив int* data, в котором будут храниться наши значения, которые затем нужно будет отсортировать.
  - Метод generate_data(int value). Метод генерирует псевдо-случайное число между 0 и 1 000 000 , сгенерированное число сохраняется в массиве.
  - Метод dump() выводит в стандартный поток вывода отсортированный массив
  - Метод swap(int* a, int* b) - обменивает значения между переменной а и b.
  - Метод build_heap() - используется для построения кучи, и поддержания свойства куча в нашем случае, наибольший элемент всегда находится в корне поддерева.
  - test1::test1() - конструктор, в нем создаем массив на 1000000 элементов
  - test1::~test1() - деструктор, после завершения, освобождаем память, занятую массивом.
  - метод sort1() - реализация сортировки кучей
  - метод sort2() - реализация сортировки выбором


# Описание сортировки кучей и выбором

# Описание метода test1::sort1() сортировка кучей

- генерируем данные в массиве с помощью функции generate_data()
- Сперва пробегаем все элементы, которые не являются, одниночными листьями(от размера массива поделенного на два до самого размера массива), вызываем функцию build_heap(). В самой функции нам нуджно поддерживать свойство кучи, в данном случае элемент в корне должне быть больше или равен левому или правому ребенку. Если нашли необходимый элемент, то вызываем функцию swap

# Описание метода test1::sort2() сортировка выбором

 Берем первый элемент, после чего начинаем обход оставшегося массива с целью найти элемент, который меньше выбранного. Если нашли от наименьший становится первым элементом. Выбираем следующий элемент, снова обходим весь массив в поисках необходимого элемента. И так далее пока не отсортируем массив в порядке возрастнания.

 # Запуск
 - Запустить исполняемый файл main. Резульат будет выведен в стандартный поток вывода
 - Запустить исполняемый файл main и перенаправить поток в файл. Например ./main > r.txt

Сперва запускаем сопртировку кучей. Чтобы запустить сортировку выбором в условной компиляции вместо **#if 1 напишите #if 0** 
